

# java相关知识

## java基础

## jvm

### 类的加载机制

**类从加载到使用有以下几个步骤：**

加载→验证→准备→解析→初始化→使用→卸载

加载：什么时候用到这个类，什么时候加载

验证：根据Java虚拟机规范来校验字节码文件是否符合指定规范。

准备：给这个类分配一定内存空间，给里面的类变量（静态变量）来一个默认的初始值。

解析：把符号引用替换为直接引用。

初始化：给静态变量赋予初值并执行静态代码块（这个和准备阶段的默认初始值不同，这个初值是我们自己设置的）

*注意：非静态变量的初始化和非静态代码块的执行是在构造函数开头隐藏执行的，注意和初始化阶段区分。*

**什么时候会初始化一个类？**

1.实例化一个类

2.包含main()方法的主类，必须马上初始化

3.如果初始化一个类的时候，父类还没初始化，必须先初始化父类。

**类加载器及双亲委派机制**

![image-20211111144030809](D:\myTypora\typora-pic\image-20211111144030809.png)

加载一个类时总是由父类先去加载，找不到再由子类加载。

这样子可以保证不会重复加载类，因为每个加载器有自己特定需要加载的类。

![image-20211111144239479](D:\myTypora\typora-pic\image-20211111144239479.png)

### jvm内存区域

![image-20211111145852821](D:\myTypora\typora-pic\image-20211111145852821.png)





![image-20211111145956815](D:\myTypora\typora-pic\image-20211111145956815.png)

直接内存并不属于JVM的内存结构，它是物理机的内存，但是JVM虚拟机可以调用该部分内存。

堆：存储**对象实例以及数组**。是垃圾收集器管理的主要区域。java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可。

元空间：用于存放类信息（如类名、访问修饰符等）、常量池、静态变量、即时编译器便宜后的代码等。

Java虚拟机栈：线程私有，生命周期与线程相同，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。

本地方法栈：与虚拟机栈发挥的作用相似，区别在于：虚拟机栈为虚拟机执行java方法（也就是字节码）服务，本地方法栈为虚拟机使用到的Native方法服务。

程序计数器：用来记录正在执行的虚拟机字节码指令地址。可通过改变这个计数器的值来选取下一条需要执行的字节码指令。



这个代码片段的内存流程串讲

![image-20211111151322256](D:\myTypora\typora-pic\image-20211111151322256.png)

![image-20211111151356150](D:\myTypora\typora-pic\image-20211111151356150.png)

#### 对象在jvm中是如何分配以及流转的？

1. 大部分对象刚创建都是在新生代的

2. 当新生代空间快被占满的时候会触发minor gc

3. 如果一个对象躲过多次minor gc（默认是15，可以调整）将会进入老年代

   - 在默认设置下，当对象年龄达到了15岁，也就是躲过了15次GC的时候，它就会转移到老年代里去。

   - 还有另一个动态对象年龄判断规则，加入当前放对象的Survivor区域中，一批对象的总大小大于Survivor区域内存的五成，那么此时大于等于这批对象年龄的对象都可以直接进入老年代。比如年龄1 + 年龄2 + 年龄n的多个年龄对象总和超过Survivor区域的百分之50，那么此时就会把年龄n以上的对象都放入老年代。

   - 我们可以设置参数，当要创建一个大于这个大小的对象，就直接把这个大对象放到老年代里去。之所以这么做就是为了避免新生代出现屡次躲过多次GC的对象，要把它在两个Survivor区域来回复制多次才能进入老年代，这样会非常耗时间。

   - 如果新生代在Minor GC之后剩余存活对象太多了，没法放入另外一块Survivor，这时就必须得把这些对象直接转移到老年代去。

     老年代对于这个策略是有**空间分配担保规则**的：

     首先会检查老年代剩余空间是否大于新生代**所有对象**的总大小，若大于，则放心进行Minor GC。

     假若老年代剩余空间小于新生代**所有对象**的总大小，那么就会看是否设置了-XX-HandlePromotionFailure这个参数，如果设置了那么就会判断老年代内存大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小，如果大于那么就会冒险进行依次Minor GC，会产生以下三种情况：

     第一种可能，Minor GC过后，剩余的**存活对象**大小小于Survivor区大小，直接放入Survivor区即可
   
     第二种可能，Minor GC过后，剩余**存活对象**大小大于Survivor区大小，小于老年代可用内存大小，就直接进入老年代。
   
     第三种可能，Minor GC过后，剩余**存活对象**大小同时大于Survivor区大小和老年代可用内存大小。此时老年代放不下这些存活对象，就会触发一次Full GC要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致OOM内存溢出
   
     如果小于或者没设置参数则直接出发Full GC

### 垃圾回收



#### 什么情况下JVM内存中的一个对象会被垃圾回收？

JVM中使用可达性分析算法来判定对象是否可以被回收，对每个对象都会分析有谁在引用他，一层层往上判断，看是否有GC Roots。 

在JVM规范中，方法的**局部变量和类的静态变量都是**GC Roots，被他们引用的对象都不会被回收。

java中有不同的引用类型，分别是强引用，软引用，弱引用和虚引用

强引用就是一个变量引用一个对象，是绝对不会被回收的。

软引用就是下面代码，一般情况下垃圾回收不会回收软引用，但是垃圾回收之后内存空间还是不够存放新对象，内存都快溢出了，那么会去回收软引用。哪怕被变量引用了。

![image-20211112114119406](D:\myTypora\typora-pic\image-20211112114119406.png)

弱引用和没引用是类似的，垃圾回收会去回收

虚引用很少用，暂时忽略

有GC Roots引用的对象不能被回收，但如果是软引用和弱引用还是可能被回收，没有GC Roots引用的对象可以被回收

如果某个对象没有GC Roots引用，那么回收时也并不是马上回收，如果这个对象重写了finalize方法，并在这个方法中重新让一个GC Roots变量引用了自己，那么他就不会被回收。

#### JVM中有哪些垃圾回收算法？各个算法优劣

**新生代的复制算法**：

原先复制算法是把内存空间一分为二，这样导致只有一半的空间能用。

真正的复制算法会做出如下优化，把新生代内存空间划分为三块：1个Eden区，2个Survivor区。前者占八成，后者各占一成。

复制算法是这样子运行的：

刚开始对象都是分配在Eden区，如果Eden区快满了，就会触发垃圾回收。此时就会把Eden区中存活对象一次性转移到空着的Survivor区。接着Eden区就会被清空，然后再次分配新对象到Eden区里。如果下次Eden区满，就会再次触发Minor GC，把Eden区和放着上次Minor GC存活对象的Survivor区内的存活对象，转移到另一块Survivor区去。接着新对象继续分配在Eden区和另外那块开始被使用的Survivor区，然后始终保持一块Survivor区是空着的，就这样一直循环使用这三块内存空间。

这么做的最大好处是，只有一成的内存空间是被闲置的，九成的内存都被使用上了。

![image-20211113144057894](D:\myTypora\typora-pic\image-20211113144057894.png)

**老年代的标记整理算法：**

标记出来当前存活的对象，这些对象可能是散乱的，让所有存活的对象都向一端移动，紧凑的靠在一起，避免出现过多垃圾碎片，然后一次性把垃圾对象回收掉。

#### parnew + cms的gc，如何保证只做ygc，fullgc次数为0，jvm参数如何设置

1.加大分代年龄，比如默认15加到30.

2.修改新生代老年代比例，比如新生代老年代比例改为2：1

3.修改e区和s区比例，比如改为6：2：2

#### G1垃圾回收器的工作原理

1.G1垃圾回收器可以同时回收新生代和老年代对象，最大的特点是把Java堆内存拆分为多个大小相等的Region

![image-20211220171257911](D:\myTypora\typora-pic\image-20211220171257911.png)

2.G1也有新生代老年代的概念，只不过是逻辑上的概念

3.G1可以做到对垃圾回收导致的系统停顿可控：G1必须要追踪每个Region里的回收价值。也就是说必须

搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以

回收多少垃圾。

G1会追踪每个Region中可以回收的对象大小和预估时间，在垃圾回收的时候，尽量把垃圾回收对系统造

成的影响控制在指定的时间范围内，同时在有限的时间回收尽可能多的垃圾对象。

![image-20211220171558100](D:\myTypora\typora-pic\image-20211220171558100.png)

4.Region可能属于新生代，也可能属于老年代，新生代和老年代各自的内存区域是不停变动的，由G1自动控制

5.目标是选择最少回收时间和最多回收对象的Region进行垃圾回收。

## 并发



# mysql

# redis

# 计网

# 操作系统

# 算法与数据结构

## 数据结构

## 算法

# 智力题