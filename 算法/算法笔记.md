# 								算法感悟

## 递归

### 递归要点

​	1.确定递归函数的参数和返回值

​	2.确定终止条件

​	3.单层递归的逻辑

### 递归时间复杂度计算

递归算法的时间复杂度 = 递归的**次数** * 每次递归的时间复杂度

### 递归空间复杂度计算

递归算法的空间复杂度 = 递归的**深度** * 每次递归的空间复杂度。

## 贪心算法

### 概念：

顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最   后得到的结果是全局最优的。

### 方法：

个人思考：

贪心算法分为分配问题和区间问题：

1.首先理解局部最优的概念：假如集合S没有构成局部最优解，那么继续在候选集合X（全集减去S）中继续挑选元素加入S直至S满足局部最优解。接着继续在X中构建局部最优解。

2.贪心很多时候和排序结合。

### 经典题型：

#### 分配问题：分配糖果（455  135）

#### 区间问题：（435）

对于区间问题，有时候往往根据第一个数组元素升序排序，或者根据第二个数组元素降序排序，往往能简化题目。

## 双指针：

### 方法：

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多    个数组的多个指针。

若两个指针指向同一数组，遍历方向相同且不会相交，则也称为**滑动窗口**（两个指针包围的区域即为当前的窗口），经常用于区间搜索。

若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是    排好序的。

### 经典题型：

#### 链表判圈（142）：

对于链表找环路的问题，有一个通用的解法——[快慢指针（Floyd  判圈法）](https://en.wikipedia.org/wiki/Cycle_detection)。给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路；如果fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻slow 和fast 相遇。当 slow 和fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为**环路的开始点**。

#### 寻找重复数（287）：（利用链表判圈思想，也可利用二分法思想，已收藏题解）

#### 滑动窗口（76）：

用i,j表示滑动窗口的左边界和右边界，通过改变i,j来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，当这个窗口包含的元素满足条件，即包含字符串T的所有元素，记录下这个滑动窗口的长度j-i+1，这些长度中的最小值就是要求的结果。

字符串的子串问题都可以用滑动窗口的思路去尝试解决一下。

#### 调整数组顺序使奇数位于偶数前面（offer21）

## 二分法：

### 概念：

二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取   一部分继续查找，将查找的复杂度大大减少。对于一个长度为 **O**(**n**) 的数组，二分查找的时间复杂度为 **O**(log **n**)。基本前提是数组有序。

### 方法：

二分法一般分为区间左闭右闭和区间左闭右开，二者不同点主要在与while条件和right的位置。

以一道题为例子：

![image-20210710204602872](D:\myTypora\typora-pic\image-20210710204602872.png)

左闭右开

![image-20210710204628685](D:\myTypora\typora-pic\image-20210710204628685.png)



左闭右闭

![image-20210710204756256](D:\myTypora\typora-pic\image-20210710204756256.png)

不同点：

1.while条件判断：因为左闭右闭情况下[left,right]是有效的,而左闭右开的情况下[left,right)是无效的。

2.high的变化: 左闭右闭情况下由于medium已经判断过，无需再判断，因此可以直接为medium - 1，即[left,medium - 1];而左闭右开的情况下，把high赋值为medium，[left,medium)此时的效果才相当于[left,medium - 1]

总结：**要维持区间不变量，上述的两个不同点都是为了去维护区间不变量的。结束循环后是否要有返回值以及是否需要加上一些判断语句根据题意再做考虑，注意举几个极端的例子，比如left和right直到不满足while条件时候所处的位置，元素只有一个或者两个的时候去检验程序。**

### 经典题型：

#### 两个数组中寻找中位数（4）：

转换成寻找第K小个数的问题

![image-20210712210130063](D:\myTypora\typora-pic\image-20210712210130063-16338716328421.png)

![image-20210712210145470](D:\myTypora\typora-pic\image-20210712210145470.png)

![image-20210712210201169](D:\myTypora\typora-pic\image-20210712210201169.png)

![image-20210712210212761](D:\myTypora\typora-pic\image-20210712210212761.png)



![image-20210712211600766](D:\myTypora\typora-pic\image-20210712211600766.png)

![image-20210712211618928](D:\myTypora\typora-pic\image-20210712211618928.png)

## 排序问题

### 快排

#### 概念：

![image-20210715202829740](D:\myTypora\typora-pic\image-20210715202829740.png)

![image-20210715202840855](D:\myTypora\typora-pic\image-20210715202840855.png)

#### 方法：

其实重要的就是partition的方法，加快排序速度的方法可以采用让随机的值作为枢轴值。

#### 经典题型

##### 寻找第K大的数（215题）

抓住partition方法即可，通过返回的值来判断应该在左边还是右边继续partition直到找到目标值。

### 桶排序

#### 概念及思想：

顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属

性），然后对桶进行排序。

#### 经典题型

##### 前K个高频元素 （347）

##### 根据字符出现频率排序(451)

## 搜索问题

### 方法：

1、当题目与边界有关时可以试着从边界出发采用dfs或者bfs。（水流问题417，被围绕区域130）

### 深度优先搜索

方法

深度优先搜索（depth-fifirst seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。

#### 经典题型

##### 岛屿的最大面积（695）

此题是经典的网格类深度优先搜索问题，每个元素代表一个节点。看起来简单，实际上是有模板的。

![image-20210718202447670](D:\myTypora\typora-pic\image-20210718202447670.png)

关键点一：dfs中的四个分叉，这也符合深度优先搜索的思想

关键点二：把已访问的grid进行修改，以防重复访问。

关键点三：非法区域的判断

##### 朋友圈个数问题（547）

每一行代表一个节点。

![image-20210718201312830](D:\myTypora\typora-pic\image-20210718201312830.png)

这题关键就是利用一个visited数组来记录当前节点是否已经被访问过。本质上是求联通分量的数量。实际上上题也可以用朋友圈思想去解决，只不过visited需要构建的大小为N*N的矩阵。

##### 水流问题（417）

![image-20210719200004139](D:\myTypora\typora-pic\image-20210719200004139.png)

![image-20210719200019756](D:\myTypora\typora-pic\image-20210719200019756.png)

![image-20210719200037588](D:\myTypora\typora-pic\image-20210719200037588.png)

这题是水往高处流的解法。虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。

##### 机器人的运动范围（offer13）：

##### 总结：

1.如果结果是基于visited数组的那么一般dfs函数无需返回东西，只需在里面修改visited数组（如547和417，岛屿问题需要返回一个岛屿的最大面积，所以需要返回int类型），然后在main函数中对visited数组遍历得出结果。**像这类题都可以试着去构建visited数组。**

2.一般二维数组中每一个元素代表一个节点，那么dfs中一般要进行四个方向的递归（如695和417，朋友圈问题是每一行代表一个节点）其实本质上都是对这个节点所直接连接的所有节点进行递归遍历，上面三题都是如此。

### 回溯法

​	**判断是否适合回溯法一般看是否能用深度优先，且是否在一种情况不合理的情况下是否需要回退状态**。

​	顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态 还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节点] 的步骤，只是多了回溯的步骤，变成了 [修改当前节点状态]→[递归子节点]→[回改当前节点状态]。

​	**两个小诀窍，一是按引用传状态，二是所有的状态修 改在递归完成后回改**

​	**回溯法一般搭配两样东西，**

​	**一样是path用来记录路径。**

​	**一样是visited用来记录是否访问过，但有时候直接在原数组上进行**

#### 经典题型：

##### 全排列问题（46）：

![image-20210720211511699](D:\myTypora\typora-pic\image-20210720211511699.png)

##### 全排列问题2（47）：

利用剪枝，好好理解  if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])  的作用。

![image-20210726200145432](D:\myTypora\typora-pic\image-20210726200145432.png)

##### 组合问题（77）：

![image-20210720211557740](D:\myTypora\typora-pic\image-20210720211557740.png)

![image-20210720211608050](D:\myTypora\typora-pic\image-20210720211608050.png)

和第一题很相似，关键在于每次递归完成后要恢复原来的状态。比如1，2，3，4进行全排列，那么以1，2开头的所有可能讨论完毕后（即dfs递归返回时）应该把2从path中移除并且置为未访问过，这样子才可以去讨论以1，3和1，4开头的全排列。

##### 组合问题2（40）：

![image-20210726204825621](D:\myTypora\typora-pic\image-20210726204825621.png)

##### 选择类问题：单词搜索（79）

方法一：

学习这种返回boolean的写法，注意backtrack中的if语句写法，这是关键。

![image-20210721201933470](D:\myTypora\typora-pic\image-20210721201933470.png)

方法二：自己方法，仍旧模仿上面两题做法，用path记录路径，当路径等于word时添加到一个ArrayList中。但是这样很死板，不好

![image-20210721202213993](D:\myTypora\typora-pic\image-20210721202213993.png)

![image-20210721202228546](D:\myTypora\typora-pic\image-20210721202228546.png)

![image-20210721202237104](D:\myTypora\typora-pic\image-20210721202237104.png)

##### N皇后问题（51）

![image-20210722201024231](D:\myTypora\typora-pic\image-20210722201024231.png)

![image-20210722201031884](D:\myTypora\typora-pic\image-20210722201031884.png)

##### 数独问题（37）：不是自己敲出来的，重写。

#### 方法套路：

1.40题和47题属于同种类型题目，都是要求**元素不重复**。这种题型他们的共同点就是**先要对数组进行排序**。当碰到一个节点和上个节点相同（上个节点已经结束它的递归，visited回溯为false），那么就跳过这个节点。这是一种剪枝的思想。避免重复比较。



2.一次dfs的调用，只改变自己这个位置的值或者状态，这样子才能回溯回来，不能去改变其他位置的值或状态。（37数独问题我本来自己的写法就犯了这个错误，不应该用双重for循环，即使当前元素有值也应该再调用dfs去判断下个位置，而不是在当前dfs的时候直接在for循环里面continue）。上面所有回溯的题都只改变当前这个元素的状态。

**3.回溯法框架**：

下面的for循环有时候可能也不需要，总之那个部分就代表做出选择的部分。

![image-20210727210211100](D:\myTypora\typora-pic\image-20210727210211100.png)

### 广度优先搜索

#### 方法：

用队列实现，把相邻的元素全部加进队列，然后弹出队列中的第一个元素重复上述过程

#### 经典题型：

##### 最短岛屿问题（934）：

先利用深度优先搜索找到第一座岛屿，然后利用广度优先搜索。

##### 单词接龙（126）：很难，看了别人题解思路也没做出来，细节太多。（已收藏题解）不是自己敲出来的

## 动态规划

### 概念：

通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，**动态规划保存子问题的解，避免重复计算**。解决动态规划问题的**关键是找到状态转移方程**，这样我们可以通过计算和储存子问题的解来求解最终问题。

**三个关键点：**

**保存子问题的解**（**即dp数组，其中注意初始化**）

**找到状态转移方程**

**空间优化（只需要看依赖于上一行的哪些列，主旨就是空间优化后，在元素更新时不能影响后续元素的更新，看背包问题）**

### 方法套路***

![image-20210802192532469](D:\myTypora\typora-pic\image-20210802192532469.png)

### 经典题型：

### 一维动态规划：

#### 爬楼梯问题（70）：

#### 打家劫舍（198）：

#### 等差数列问题（413）：

#### 斐波那契数列（offer10-I）：

#### 青蛙跳台阶问题（offer10-II）：

### 二维动态规划：

#### 最小路径和（64）：

#### 01矩阵（542）：（可动态规划，也可广度优先遍历）

学习本题的思路，如果一个点的值依赖于其四周方向的值，那么可以从左上先遍历。，再从右下再遍历。两个方向结合后就考虑了四个方向。

### 分割类型题：

#### 剪绳子I（offer14）（贪心算法速度更快）：

#### 剪绳子II（offer14）（比上题多了越界的情况）：

#### 完全平方数（279）：

状态转移方程的证明：

![image-20210731152135349](D:\myTypora\typora-pic\image-20210731152135349.png)

上面的K应该不是最大的平方数，而是任意一个平方数。

![image-20210731152153343](D:\myTypora\typora-pic\image-20210731152153343.png)

#### 解码方法（91）：

实际上就是看当前这个元素能否和上个元素编码成一个字符。

#### 单词拆分（139）：

### 子序列问题：

#### 最长上升子序列（300）：最优解法已收藏题解

#### 最长公共子序列（1143）

### 背包问题：

#### 方法套路：

![image-20210803195743035](D:\myTypora\typora-pic\image-20210803195743035.png)

![image-20210803195756855](D:\myTypora\typora-pic\image-20210803195756855.png)

![image-20210803195847548](D:\myTypora\typora-pic\image-20210803195847548.png)

![image-20210803195855706](D:\myTypora\typora-pic\image-20210803195855706.png)

![image-20210803195903380](D:\myTypora\typora-pic\image-20210803195903380.png)



#### 0-1背包问题：

##### 方法套路：什么类型的题目可以转换成0-1背包问题？

就是在一个数组中选出一些东西，使得他满足一个类似容量的条件。并且选出的东西只能选择一次，不能重复选择。

**dp[i][j\] = Math.Max(dp[i - 1\][j\] , dp[i - 1\][j - v\] +w);**

这是0-1背包问题的状态转移方程。

##### 分割等和子集（416）：

##### 一和零（474）：



#### 完全背包问题：

**由于一个物体可以取多次，那么这个物体要么不取，要么就得讨论他在取不同次数的情况下，何时价值最大。**

推导过程如下：

//不取，取一次，取两次，取三次。。。。。。。。。

dp[i][j\] = Math.Max(dp[i - 1\][j\] , dp[i - 1\][j - v\] + w,dp[i - 1\][j - 2v\] + 2w,dp[i - 1\][j - 3v\] + 3w,.........);

又因为dp[i\][j - v\] = Math.Max(dp[i - 1\][j - v\] , dp[i - 1\][j - 2v\] + w,dp[i - 1\][j - 3\] + 2w,dp[i - 1\][j - 4v\] + 3w,.........);

那么我们观察可得，dp[i\][j - v\] + w = Math.Max(dp[i - 1\][j - v\] + w,dp[i - 1\][j - 2v\] + 2w,dp[i - 1\][j - 3v\] + 3w,.........);

所以把dp[i\][j - v\] + w代入第一个式子中，第一个式子变为

**dp[i][j\] = Math.Max(dp[i - 1\][j\] , dp[i\][j - v\] +w);**

这就是完全背包问题的状态转移方程。

##### 零钱兑换（322）：



### 字符串编辑：

#### 编辑距离（72）：

类似于1143题，最长公共子序列。

#### 正则表达式匹配（10）：

### 股票交易：

#### 买卖股票的最佳时机（121）：

#### 买卖股票的最佳时机IV（188）：//最通用的一题，其他类型股票在此基础上改变dp数组和状态转移方程。

#### 买卖股票的最佳时机含冷冻期（309）

### 其他问题：

#### 打家劫舍II（213）

#### 最大子序和（53）

#### 整数拆分（343）

#### 两个字符串的删除操作（583）：转换成最长公共子序列问题。

## 分治法

![image-20210811183723809](D:\myTypora\typora-pic\image-20210811183723809.png)

### 经典题型：

#### 表达式问题：

##### 为运算表达式设计优先级（241）

## 数学问题：

### 经典题型：

#### 数值的整数次方（offer16）：

![image-20211023092414519](D:\myTypora\typora-pic\image-20211023092414519.png)

#### 质数问题：计数质数（204）

![image-20210813184240130](D:\myTypora\typora-pic\image-20210813184240130.png)

#### 阶乘后的0的个数（172）：

![image-20210813190034929](D:\myTypora\typora-pic\image-20210813190034929.png)

#### Excel表列名称（168）

##### 方法1：

![image-20210814184851305](D:\myTypora\typora-pic\image-20210814184851305.png)

如果本体的26进制是0-25，那么就不会出现问题，但本体是1-26.

##### 方法2：

如果余数是0，就像上一位借个1（26）出来，让余数强行等于26

#### 除自身以外数组的乘积（238）：

乘积 = 左边所有数的乘积 * 右边所有数的乘积。

#### 多数元素（169）：

![image-20210815085438892](D:\myTypora\typora-pic\image-20210815085438892.png)

#### 快乐数（202）：

用判断链表是否有环的思想。一种是利用集合，一种是利用快慢指针。

#### 打印从一到最大的n位数（offer17）

考虑下大数问题

## 位运算

### 常用技巧：

![image-20210816190957193](D:\myTypora\typora-pic\image-20210816190957193.png)

如何得到整数n的二进制表示形式的最后一位:n & 1.

### 经典题型：

#### 二进制中一的位数（offer15）：

1.按位与1

2.n与n-1

#### 颠倒二进制位（190）：

题目所给的输入n是int类型，示例中的二进制只是n的二进制表示，如：示例为11111111111111111111111111111101表示n为-3（计算机中补码存储）。n>>1，实际上就相当于二进制向右移动一位。n除以2.

#### 只出现一次的数字（136）：

利用x ^ x = 0的性质，以及异或满足交换律（不满足分配律）。

#### 丢失的数字（268）：

a  = a  ^ b ^ b

因为b ^ b = 0,a ^ 0 = a

#### 只出现一次的数字III（260）：

将这个问题转化成两个136题类型的数组分别求解。

a & (-a)，将保留从右往左数得到的第一个1，其余位置为0的一个数。

而这个1恰好是由于异或中某一位不同所得到的。将这个数与原数组每个数相与，为0的分为一组，不为0的分为另一组。

![image-20210817192734101](D:\myTypora\typora-pic\image-20210817192734101.png)

## 数据结构之数组

### 经典题型：

#### 旋转数组的最小数字（剑指11）

#### 找出数组中重复的数字（剑指3）

#### 找到所有数组中消失的数字（448）

#### 旋转图像（48）

![image-20210818201427807](D:\myTypora\typora-pic\image-20210818201427807.png)

#### 搜索二维矩阵II（240）

从右上角遍历，若元素大于当前值，则向下移动，否则向左移动。类似于二叉搜索树。妙啊！！！！！

#### 最多能完成排序的块（769）

不断更新当下区间的最右端，当遍历的下标与最右端重合的时候，说明这个区间已经自洽了

#### 顺时针打印矩阵（offer29）

## 数据结构之栈和队列

### 经典题型：

#### 栈的压入弹出序列（offer31）

#### 用栈实现队列（232）

#### 用队列实现栈（225）

#### 最小栈（155）

#### 有效的括号（20）

## 数据结构之单调栈

### 经典题型：

#### 每日温度（739）

## 数据结构之优先级队列（堆）

单调队列在下面双端队列的题目中有用到。

![image-20210825193110194](D:\myTypora\typora-pic\image-20210825193110194.png)

### 注意事项：

默认是最小堆，最大堆需要重写compare方法。23题重写过程如下（因为他是链表，需要根据val排序）

![image-20210823191539397](D:\myTypora\typora-pic\image-20210823191539397.png)

### 经典题型：

#### 合并K个升序链表（23）：

方法1：优先级队列

方法2：递归合并（如果不懂先去看21题两个链表如何递归合并）

#### 天际线问题（218）：没看懂，不是自己敲出来的。已收藏题解

## 数据结构之双端队列（此题也用到了单调队列的思想）

### 经典题型：

#### 滑动窗口最大值（239）

## 数据结构之哈希表

### 经典题型：

#### 最长连续序列（128）

#### 直线上最多的点数（149）不是自己敲出来的

斜率问题：分子分母除以最大公约数后用字符串保存。

##### 求两个数的最大公约数用辗转相除法。

![image-20210826194507560](D:\myTypora\typora-pic\image-20210826194507560.png)

#### 重新安排行程（332）IDEA运行正常但是leecode运行失败，重做。

## 数据结构之前缀和与积分图

### 经典题型：

#### 区域和检索（303）

利用前缀和的思想保存子问题的解，dp[i]表示前i个元素的和。

#### 二维区域和检索（304）

同样利用前缀和思想

#### 和为k的子数组（560）

也利用到了前缀和思想，不过需要用HashMap来缩减时间复杂度。

## 数据结构之其他题型：

### 重塑矩阵（566）

### 下一个更大元素（503）

### 数组的度（697）

### 最长和谐子序列（594）

### 超级丑数（313）：

![image-20210902213336796](D:\myTypora\typora-pic\image-20210902213336796.png)

假设primes为【2,7,13,19】

由于采用动态规划，那么，dp[i]必定是基于前面的结果的。根据上面图片可知，dp[i]等于前面的某结果(dp[0]到dp[i - 1])乘以某个primes[]中的数。

那么问题就变成如何选择dp[i]之前的结果和primes[]中的数使之乘积最小。这个乘积就是dp[i]

我们先从dp[1]出发（dp[0]是1）,也就是说dp[1]是dp[0]乘以某个primes[i]得到的，容易得出dp[0]乘以2的乘积最小，那么dp[1]就是2.

那么dp[2]就是dp[0]和dp[1]中选个数乘以某个prime中的数的乘积，那么由于我们的**dp[1]是dp[0]乘以2得到的**，**那么dp[2]还能使用dp[0]乘以2吗？显然不能**，如果能得话那么最小的乘积岂不是永远为dp[0]乘以2了（因为dp和primes都为递增数列）.所以此时应该用dp[1]乘以2,然后因为没有某个dp是基于7,13,19,产生的，那么应该用dp[0]乘以7，13，19(这样子乘积才是最小。才有比较的意义)

所以dp[1] * 2 = 4,dp[0] * 7 = 7,dp[0] * 13 = 13, dp[0] * 19 = 19.所以dp[2]应该为4.

此时我们想到，应该新建一个数组indexs来保存primes中的元素应该和哪个dp相乘。而且注意，比如某个dp是14,那么他有可能依赖于2产生也有可能依赖于7产生，那么indexs中2和7的部分应该都加1

接下来的分析和上面一致，不理解可拿代码单步跟踪。



### 优势洗牌（870）：

## 字符串

### 字符串比较：

#### 有效的字母异位词（242）：

#### 同构字符串（205）：

#### 回文子串（647）：

1.暴力法

2.动态规划

3.中心扩展法

#### 计数二进制字串（696）：

### 字符串理解：

有统一解法，计算器问题。

#### 基本计算器（224）：双栈解决

#### 基本计算器II（227）：双栈解决

#### 基本计算器III（772）：双栈解决。

### 字符串匹配：

#### 实现strStr（28）:

1.暴力解法

2.kmp算法

### 其他题型：

#### 表示数值的字符串（offer20）：

#### 最长回文串（409）：

#### 无重复字符的最长子串（3）：

这类子串问题都可以尝试从滑动窗口的思路去解决。

#### 最长回文子串（5）：

1.暴力法

2.动态规划

3.中心扩展法

#### 替换空格（05）

## 链表

### 经典题型：

#### 反转单链表（206）：

1.递归解法

2.非递归解法

#### 合并两个有序链表（21）：

1.递归解法

2.非递归解法

#### 两两交换链表中的节点（24）：

1.递归解法

2.非递归解法

#### 相交链表（160）：

#### 回文链表（234）：

1.反转前半部分

2.反转后半部分（看自己的总结的代码）

#### 删除排序链表中的重复元素（83）：

1.递归解法

2.非递归解法

#### 奇偶链表（328）：

#### 链表的倒数第K个节点（offer22）：

#### 删除链表的倒数第N个节点（19）：	

#### 从尾到头打印链表（offer06）:

1.辅助栈

2.反转链表

#### 删除链表的节点（offer18）：

## 树

### 经典题型：

#### 树的递归

##### 二叉树的最大深度（104）

递归

##### 二叉平衡树（110）

递归

##### 二叉树的直径（543）：

递归

##### 路径总和（437）：

前缀和思想，先序遍历

##### 对称二叉树（101）：

1.递归解法

2.非递归解法

##### 删点成林（1110）

递归

##### 树的子结构（offer26）

这题首先要化繁为简，要**先学会如何判断B是否是以A为根节点的树的子结构**，然后先序遍历，逐个去判断。

#### 层次遍历

##### 二叉树的层平均值（637）

#### 前中后序遍历

##### 从前序与中序遍历序列构造二叉树（105）

前序判断根，中序判断左右。

##### 从后序与中序遍历序列构造二叉树（106）

后序判断根，中序判断左右

![image-20211011085637127](D:\myTypora\typora-pic\image-20211011085637127.png)

无论105还是106，关键步骤都是先在前序或后序中找到根节点，然后根据中序把整个数组分为左子树和右子树。

接下来去确定中序遍历数组中左子树右子树范围，前序或者后序遍历数组中左子树右子树范围。

##### 前序遍历（144）

1.递归

2.迭代

3.morris遍历

##### 中序遍历（94）

1.递归

2.迭代

3.morris遍历

##### 后序遍历（145）

1.递归

2.迭代

3.如果不依赖队列，就是左右根的遍历顺序该怎么做？

#### 二叉查找树

##### 恢复二叉搜索树（99）

中序morris遍历

##### 修剪二叉搜索树（669）

#### 字典树

##### 实现Trie（前缀树）（208）

#### 其他题型

##### 翻转二叉树（226）

##### 合并二叉树（617）

##### 另一棵树的子树（572）

这题需要先去掌握如何判断是否是同一棵树的算法。

判断是否是同一棵树的算法的思考方式（递归的思考方式）：

1.返回什么：返回的是当前这个节点的树是否相等

2.终止条件：都为null的时候返回true，只有一个为null返回false，都不为null但两个值不相等返回false

3.每次递归应该做什么：根据返回的东西来看，如果当前节点相等，只要判断左右子树是否相等即可，所以再次套用递归

![image-20211009083622589](D:\myTypora\typora-pic\image-20211009083622589.png)

##### 左叶子之和（404）

##### 二叉树的最近公共祖先（236）

![image-20211012112256670](D:\myTypora\typora-pic\image-20211012112256670.png)

##### 有序链表转换二叉搜索树（109）

1.转换成数组求中点

2.快慢指针求中点

3.利用中序遍历的性质。

## 图

### 拓扑排序

1.构造邻接矩阵或者邻接表来存储边之间的关系

2.统计每个节点的入度

3.把那些入度为0的节点加入队列

4.依次弹出队列中的元素并加入答案res，把这些元素指向的节点的入度减一，若减一后入度为0，也加入队列

5.重复4直到队列为空

6.假如res最终的元素个数不等于总的节点的个数，说明存在环（因为他们的入度始终不为0，无法加入res）

#### 课程表II（210）：

## 并查集

![image-20211014103904996](D:\myTypora\typora-pic\image-20211014103904996.png)

注意，连接两个集合时，是把两个集合的代表节点（最终祖先）相连。

### 冗余连接（684）：

## 复合数据结构

#### LRU缓存机制（146）：
